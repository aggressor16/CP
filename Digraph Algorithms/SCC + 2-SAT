#include <bits/stdc++.h>
using namespace std;

#ifdef LOCAL
#include "debug.h"
#else
#define debug(...) 42
#endif

class Strongly_Connected_Components {
public:
  int n;
  vector <int> c;
  vector <int> order;
  vector <bool> used;
  vector <vector <int>> adj;
  vector <vector <int>> adj_rev;

  void dfs_1(int v) {
    used[v] = true;
    for (int to : adj[v]) {
      if (!used[to]) {
        dfs_1(to);
      }
    }
    order.push_back(v);
  }

  void dfs_2(int v) {
    for (int to : adj[v]) {
      if (c[to] == -1) {
        c[to] = c[v];
        dfs_2(to);
      }
    }
  }

  Strongly_Connected_Components(){
  }

  int scc_count = -1;
  Strongly_Connected_Components(const vector <vector <int>> &_adj) {
    adj = _adj;
    n = (int)adj.size();
    used.resize(n);
    c.assign(n, -1);
    order.reserve(n);
    adj_rev.resize(n);

    for (int i = 0; i < n; ++i) {
      for (int to : adj[i]) {
        adj_rev[to].push_back(i);
      }
    }
  }

  vector <int> find_scc() {
    for (int i = 0; i < n; ++i) {
      if (!used[i]) {
        dfs_1(i);
      }
    }
    scc_count = 0;
    for (int i = n - 1; i >= 0; --i) {
      int v = order[i];
      if (c[v] != -1) {
        continue;
      }
      c[v] = scc_count++;
      dfs_2(v);
    }
    return c;
  }

  vector <vector <int>> condensation() {
    assert(scc_count != -1);
    vector <int> C = find_scc();
    vector <vector <int>> res(scc_count);
    vector <unordered_set <int>> was(scc_count); //have no idea how to get rid of hash table
    for (int i = 0; i < n; ++i) {
      for (int to : adj[i]) {
        if (C[i] == C[to]) {
          continue;
        }
        assert(C[i] < C[to]);
        auto [iter, succ] = was[C[i]].insert(C[to]);
        if (succ) {
          res[C[i]].push_back(C[to]);
        }
      }
    }
    return res;
  }
};

class Two_Sat {
public:
  int n;
  vector <vector <int>> adj;
  Strongly_Connected_Components Scc;

  Two_Sat() {
  }

  Two_Sat(int _n) {
    n = _n;
    adj.resize(2 * n);
  }

  inline void add(int x, int value_x, int y, int value_y) { //(x || y)
    assert(0 <= x && x <= n - 1 && 0 <= value_x && value_x <= 1);
    assert(0 <= y && y <= n - 1 && 0 <= value_y && value_y <= 1);
    adj[2 * x + (value_x ^ 1)].push_back(2 * y + value_y);
    adj[2 * y + (value_y ^ 1)].push_back(2 * x + value_x);
  }

  vector <int> solve() {
    Scc = Strongly_Connected_Components(adj);
    vector <int> c = Scc.find_scc();
    vector <int> res(n);
    for (int i = 0; i < n; ++i) {
      if (c[2 * i] == c[2 * i + 1]) {
        return vector <int> (); //no solution
      }
      res[i] = c[2 * i] < c[2 * i + 1];
    }
    return res;
  }
};

void run_case() {
  int n, m;
  cin >> n >> m;

  vector <int> a(n);
  for (int i = 0; i < n; ++i) {
    cin >> a[i];
  }

  vector <vector <int>> adj(n);
  for (int i = 0; i < m; ++i) {
    int x;
    cin >> x;
    for (int j = 0; j < x; ++j) {
      int door;
      cin >> door;
      door -= 1;
      adj[door].push_back(i);
    }
  }

  Two_Sat ts(m);
  for (int i = 0; i < n; ++i) {
    assert((int)adj[i].size() == 2);
    int u = adj[i][0];
    int v = adj[i][1];
    if (a[i] == 1) { //we must switch either 0 or 2 doors
      ts.add(u, 1, v, 0);
      ts.add(u, 0, v, 1);
    } else { //we must switch exactly one door
      ts.add(u, 0, v, 0);
      ts.add(u, 1, v, 1);
    }
  }

  vector <int> res = ts.solve();
  if (res.empty()) {
    cout << "NO\n";
  } else {
    cout << "YES\n";
  }
}

signed main() {
  ios::sync_with_stdio(false);
  cin.tie(0);

  int test_cases = 1;
  //cin >> test_cases;

  while (test_cases--) {
    run_case();
  }

  return 0;
}
